# -*- coding: utf-8 -*-
"""Automatas v1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jWYsCK_3w-MOb4VI8UavCV5wsf4NTa-0
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib import animation
from matplotlib import colors
from matplotlib.patches import Rectangle
from matplotlib.colors import Normalize
from IPython.display import HTML
from numba import jit

from datetime import timedelta,datetime

class WFSim:
    def __init__(self, f=0.01, p=1e-6, bedrock=0.005, water=0.005, h=16, w=16):
        self.f = f #fire proba
        self.p = p #tree growing proba
        self.h = h #grid height
        self.w = w #grid width
        self.bedrock = bedrock #bedrock proba
        self.water = water #water proba
        #np.random.seed(3)
        #np.random.seed(33)
        #np.random.seed(333)
        #np.random.seed(3333)
        #np.random.seed(33333)
        np.random.seed(333333)
        self.landscape = np.random.randint(0,2,(self.h,self.w)) #0 - grass, 1 - tree

        for i in range(self.landscape.shape[0]):
            for j in range(self.landscape.shape[1]):
                coef = 5 if self.surf_neighbors_check(i, j, "B") else 1
                if self.bedrock*coef>np.random.random():
                    self.landscape[i, j] = -2

                coef = 10 if self.surf_neighbors_check(i, j, "W") else 0.1
                if self.water*coef>np.random.random():
                    self.landscape[i, j] = -3

    def fire_neighbors_check(self, idx, jdx):
        check = False
        offsets = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]
        #offsets = coordinates of all the neighbors of a cell (0,0)

        for di,dj in offsets: #checking if any of the neighbors have fire
            ni, nj = idx+di, jdx+dj
            if nj>=0 and ni>=0 and ni<self.h and nj<self.w:
                if self.landscape[ni, nj] == 2:
                    check +=True
        return check
    def surf_neighbors_check(self, i, j, type_check):
        """
        Verifica si un vecino cercano tiene un tipo específico de terreno: 'B' para Bedrock o 'W' para Water.
        """
        offsets = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
        for di, dj in offsets:
            ni, nj = i + di, j + dj
            if 0 <= ni < self.h and 0 <= nj < self.w:  # Verifica los límites
                if type_check == "B" and self.landscape[ni, nj] == -2:  # Bedrock
                    return True
                if type_check == "W" and self.landscape[ni, nj] == -3:  # Water
                    return True
        return False

    def step(self, step):

        new_landscape = self.landscape.copy()

        for i in range(self.landscape.shape[0]):
            for j in range(self.landscape.shape[1]):

                if self.landscape[i, j]==2:
                    new_landscape[i, j] = -1 #ash after fire

                if self.p > np.random.rand() and self.landscape[i, j]==0:
                    new_landscape[i, j] = 1 #growing a tree

                if (self.f > np.random.rand() or self.fire_neighbors_check(i, j)) and self.landscape[i, j]==1:
                    new_landscape[i, j] = 2 #firing a tree
        self.landscape = new_landscape.copy()

def update(frame):
    im.set_data(Sim.landscape)
    ax.axis('off')
    Sim.step(frame)
    return [im]

colors_list = ['steelblue', 'grey','black', 'olivedrab', 'forestgreen', 'orange']
cmap = colors.ListedColormap(colors_list)
bounds = [-3,-2,-1,0,1,2,3]

Sim = WFSim(h=32, w=32) #initializing the simulation
#np.random.seed(12)


fig, ax = plt.subplots(figsize=(16,16))
#im = ax.imshow(Sim.landscape, cmap=cmap, norm=norm)
plt.subplots_adjust(top = 1, bottom = 0, right = 1, left = 0,
            hspace = 0, wspace = 0)
# Definir un norm para la normalización
#norm = colors.BoundaryNorm(bounds, cmap.N)
norm = Normalize(vmin=-3, vmax=3)



im = ax.imshow(Sim.landscape, cmap=cmap, norm=norm)
ani = animation.FuncAnimation(fig, update, frames=range(0, 500, 10), interval=50) #frames - the number of steps in the simulation
#ani.save('simple.gif', fps=1.5, savefig_kwargs={'pad_inches':0})
#plt.show()
HTML(ani.to_jshtml())

